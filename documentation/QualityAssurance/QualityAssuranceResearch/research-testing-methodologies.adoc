= Test Case Design Methodologies
:toc: macro
:toc-title: Table of Contents

The information below documents the conducted research and evaluation of three fundamental test case design methodologies. The objective is to standardize our testing framework, minimize redundancy, and ensure high defect detection rates across the software architecture.

toc::[]

== Analysis

=== Equivalence Partitioning (EP) & Boundary Value Analysis (BVA)

*Type:* Black-Box Testing +
*Focus:* Input Validation and Data Integrity

*Description:* ::
* *Equivalence Partitioning:* Divides input data into valid and invalid partitions. It assumes that if one value in a partition works, others in the same partition will also work.
* *Boundary Value Analysis:* Focuses on the values at the edges of these partitions, as this is where defects most commonly occur.

*Applicability:* ::
* Essential for all user input forms like login, sign-up, checkout.
* Critical for API endpoint payload validation.

*Pros:* ::
* Reduces the number of test cases while maintaining high coverage.
* High ROI (Return of Investment) for detecting off-by-one errors.

*Cons:* ::
* Does not test the interaction between different input fields, only individual fields.

'''

=== Decision Table Testing

*Type:* Black-Box Testing +
*Focus:* Complex Business Login and Rules

*Description:* ::
* A tabular representation used to capture complex logic where system behavior is determined by multiple combinations of inputs.
* Columns represent rules; rows represent conditions (inputs) and actions (outputs).

*Applicability:* ::
* Ideal for features with conditional logic, such as permission settings, discount code validity, or shipping calculation rules.

*Pros:* ::
* Guarantees that every possible combination of conditions is considered.
* Exposes logic gaps or contradictory requirements early in the design phase.

*Cons:* ::
* Can become complex and hard to maintain if the number of conditions is large.

'''

=== Basis Path Testing

*Type:* White-Box Testing +
*Focus:* Code Structure and Logic Flow

*Description:* ::
* A structural testing technique that uses the control flow graph of the code to calculate Cyclomatic Complexity.
* It ensures that every independent path through the code is executed at least once.

*Applicability:* ::
* Best applied to critical backend algorithms and complex functions where branching (if/else, loops) is heavy.

*Pros:* ::
* Ensures 100% statement and branch coverage.
* Reduces redundant tests by focusing on unique paths.

*Cons:* ::
* Requires access to source code and high technical knowledge.
* Time-consuming for simple CRUD operations.

== Tooling Assessment

These methodologies need the following tooling stacking:

.Unit and White-Box Testing
* *Tools:* Jest (JS/TS), Pytest (Python), JUnit (Java)
* *Usage:* Use coverage reports to measure Basis Path coverage

.API and Black-Box Testing
* *Tools:* Postman/Newman or Playwright
* *Usage:* Implement data-driven testing using CSV/JSON files to automate Equivalence Partitioning scenarios.

.Test Management
* *Tools:* Jira (Xray/Zephyr) or a simple GitHub Project Markdown table.
* *Usage:* Document Decision Tables directly in the test plan tickets

== Recommendation

For the corresponding project, a *Hybrid Tiered Strategy* should be taken into consideration rather than relying on a single method. Taking on a single technique won't cover all failure modes.

The following methods are suggested:

[horizontal]
All inputs:: Apply EP and BVA to every API endpoint and UI form.
Business Logic:: Create Decision Table for complex workflows.
Critical Algorithms:: Enforce Basis Path Testing only on complex backend utilities where failure is not an option.